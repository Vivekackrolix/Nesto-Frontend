{"version":3,"file":"static/js/941.380792a4.chunk.js","mappings":"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","sources":["../node_modules/@tanstack/query-core/src/focusManager.ts","../node_modules/@tanstack/query-core/src/logger.ts","../node_modules/@tanstack/query-core/src/mutation.ts","../node_modules/@tanstack/query-core/src/notifyManager.ts","../node_modules/@tanstack/query-core/src/onlineManager.ts","../node_modules/@tanstack/query-core/src/query.ts","../node_modules/@tanstack/query-core/src/queryCache.ts","../node_modules/@tanstack/query-core/src/mutationCache.ts","../node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts","../node_modules/@tanstack/query-core/src/queryClient.ts","../node_modules/@tanstack/query-core/src/removable.ts","../node_modules/@tanstack/query-core/src/retryer.ts","../node_modules/@tanstack/query-core/src/subscribable.ts","../node_modules/@tanstack/query-core/src/utils.ts","../node_modules/@tanstack/react-query/src/QueryClientProvider.tsx","../node_modules/@tanstack/react-query/src/useSyncExternalStore.ts","../node_modules/@tanstack/query-core/src/mutationObserver.ts","../node_modules/@tanstack/react-query/src/useMutation.ts","../node_modules/@tanstack/react-query/src/utils.ts"],"sourcesContent":["import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  private focused?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', listener, false)\n        window.addEventListener('focus', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n          window.removeEventListener('focus', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    this.focused = focused\n\n    if (focused) {\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach((listener) => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState,\n    )\n  }\n}\n\nexport const focusManager = new FocusManager()\n","export interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\nexport const defaultLogger: Logger = console\n","import type { MutationOptions, MutationStatus, MutationMeta } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport type { Retryer } from './retryer'\nimport { canFetch, createRetryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  logger?: Logger\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n  meta?: MutationMeta\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  private mutationCache: MutationCache\n  private logger: Logger\n  private retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.defaultOptions = config.defaultOptions\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.logger = config.logger || defaultLogger\n    this.observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options?: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc()\n      } else {\n        this.mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return this.retryer?.continue() ?? this.execute()\n  }\n\n  async execute(): Promise<TData> {\n    const executeMutation = () => {\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found')\n          }\n          return this.options.mutationFn(this.state.variables!)\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({ type: 'failed', failureCount, error })\n        },\n        onPause: () => {\n          this.dispatch({ type: 'pause' })\n        },\n        onContinue: () => {\n          this.dispatch({ type: 'continue' })\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode,\n      })\n\n      return this.retryer.promise\n    }\n\n    const restored = this.state.status === 'loading'\n    try {\n      if (!restored) {\n        this.dispatch({ type: 'loading', variables: this.options.variables! })\n        // Notify cache callback\n        await this.mutationCache.config.onMutate?.(\n          this.state.variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(this.state.variables!)\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables,\n          })\n        }\n      }\n      const data = await executeMutation()\n\n      // Notify cache callback\n      await this.mutationCache.config.onSuccess?.(\n        data,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(\n        data,\n        this.state.variables!,\n        this.state.context!,\n      )\n\n      // Notify cache callback\n      await this.mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(\n        data,\n        null,\n        this.state.variables!,\n        this.state.context,\n      )\n\n      this.dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.mutationCache.config.onError?.(\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n\n        await this.options.onError?.(\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.mutationCache.config.onSettled?.(\n          undefined,\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.dispatch({ type: 'error', error: error as TError })\n      }\n    }\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'loading':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n","import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\nexport function createNotifyManager() {\n  let queue: NotifyCallback[] = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends Function>(callback: T): T => {\n    return ((...args: any[]) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }) as any\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setOnline: (online?: boolean) => void,\n) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable {\n  private online?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline()\n        // Listen to online\n        window.addEventListener('online', listener, false)\n        window.addEventListener('offline', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener)\n          window.removeEventListener('offline', listener)\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    this.online = online\n\n    if (online) {\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach((listener) => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import { getAbortController, noop, replaceData, timeUntilStale } from './utils'\nimport type {\n  InitialDataFunction,\n  QueryKey,\n  QueryOptions,\n  QueryStatus,\n  QueryFunctionContext,\n  QueryMeta,\n  CancelOptions,\n  SetDataOptions,\n  FetchStatus,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport type { Retryer } from './retryer'\nimport { isCancelledError, canFetch, createRetryer } from './retryer'\nimport { Removable } from './removable'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  logger?: Logger\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: any\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal?: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n  ) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  initialState: QueryState<TData, TError>\n  revertState?: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  private cache: QueryCache\n  private logger: Logger\n  private promise?: Promise<TData>\n  private retryer?: Retryer<TData>\n  private observers: QueryObserver<any, any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  private abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.abortSignalConsumed = false\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.logger = config.logger || defaultLogger\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || getDefaultState(this.options)\n    this.state = this.initialState\n    this.scheduleGc()\n  }\n\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some((observer) => observer.options.enabled !== false)\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some((observer) => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({ revert: true })\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = getAbortController()\n\n    // Create query function context\n    const queryFnContext: QueryFunctionContext<TQueryKey> = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true\n            return abortController.signal\n          }\n          return undefined\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn')\n      }\n      this.abortSignalConsumed = false\n      return this.options.queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData, TQueryKey> = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(context)\n\n    // Store state in case the current fetch needs to be reverted\n    this.revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.cache.config.onError?.(error, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.retryer = createRetryer({\n      fn: context.fetchFn as () => TData,\n      abort: abortController?.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error('undefined') as any)\n          return\n        }\n\n        this.setData(data as TData)\n\n        // Notify cache callback\n        this.cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.promise = this.retryer.promise\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = typeof data !== 'undefined'\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle',\n  }\n}\n","import type { QueryFilters } from './utils'\nimport { hashQueryKeyByOptions, matchQuery, parseFilterArgs } from './utils'\nimport type { Action, QueryState } from './query'\nimport { Query } from './query'\nimport type { NotifyEvent, QueryKey, QueryOptions } from './types'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (error: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: unknown | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ntype QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  config: QueryCacheConfig\n\n  private queries: Query<any, any, any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor(config?: QueryCacheConfig) {\n    super()\n    this.config = config || {}\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter((x) => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKey,\n    arg2?: QueryFilters,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.queries.find((query) => matchQuery(filters, query))\n  }\n\n  findAll(queryKey?: QueryKey, filters?: QueryFilters): Query[]\n  findAll(filters?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return Object.keys(filters).length > 0\n      ? this.queries.filter((query) => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(event: QueryCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","import type { MutationObserver } from './mutationObserver'\nimport type { MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport { notifyManager } from './notifyManager'\nimport type { Action, MutationState } from './mutation'\nimport { Mutation } from './mutation'\nimport type { MutationFilters } from './utils'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: unknown | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\ntype MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  config: MutationCacheConfig\n\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n  private resuming: Promise<unknown> | undefined\n\n  constructor(config?: MutationCacheConfig) {\n    super()\n    this.config = config || {}\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter((x) => x !== mutation)\n    this.notify({ type: 'removed', mutation })\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.mutations.forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.mutations.find((mutation) => matchMutation(filters, mutation))\n  }\n\n  findAll(filters: MutationFilters): Mutation[] {\n    return this.mutations.filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    this.resuming = (this.resuming ?? Promise.resolve())\n      .then(() => {\n        const pausedMutations = this.mutations.filter((x) => x.state.isPaused)\n        return notifyManager.batch(() =>\n          pausedMutations.reduce(\n            (promise, mutation) =>\n              promise.then(() => mutation.continue().catch(noop)),\n            Promise.resolve() as Promise<unknown>,\n          ),\n        )\n      })\n      .then(() => {\n        this.resuming = undefined\n      })\n\n    return this.resuming\n  }\n}\n","import type { QueryBehavior } from './query'\n\nimport type {\n  InfiniteData,\n  QueryFunctionContext,\n  QueryOptions,\n  RefetchQueryFilters,\n} from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData,\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: (context) => {\n      context.fetchFn = () => {\n        const refetchPage: RefetchQueryFilters['refetchPage'] | undefined =\n          context.fetchOptions?.meta?.refetchPage\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal?.aborted) {\n                cancelled = true\n              } else {\n                context.signal?.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn || (() => Promise.reject('Missing queryFn'))\n\n        const buildNewPages = (\n          pages: unknown[],\n          param: unknown,\n          page: unknown,\n          previous?: boolean,\n        ) => {\n          newPageParams = previous\n            ? [param, ...newPageParams]\n            : [...newPageParams, param]\n          return previous ? [page, ...pages] : [...pages, page]\n        }\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean,\n        ): Promise<unknown[]> => {\n          if (cancelled) {\n            return Promise.reject('Cancelled')\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const queryFnResult = queryFn(queryFnContext)\n\n          const promise = Promise.resolve(queryFnResult).then((page) =>\n            buildNewPages(pages, param, page, previous),\n          )\n\n          return promise\n        }\n\n        let promise: Promise<unknown[]>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          const shouldFetchFirstPage =\n            refetchPage && oldPages[0]\n              ? refetchPage(oldPages[0], 0, oldPages)\n              : true\n\n          // Fetch first page\n          promise = shouldFetchFirstPage\n            ? fetchPage([], manual, oldPageParams[0])\n            : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]))\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then((pages) => {\n              const shouldFetchNextPage =\n                refetchPage && oldPages[i]\n                  ? refetchPage(oldPages[i], i, oldPages)\n                  : true\n\n              if (shouldFetchNextPage) {\n                const param = manual\n                  ? oldPageParams[i]\n                  : getNextPageParam(context.options, pages)\n                return fetchPage(pages, manual, param)\n              }\n              return Promise.resolve(\n                buildNewPages(pages, oldPageParams[i], oldPages[i]),\n              )\n            })\n          }\n        }\n\n        const finalPromise = promise.then((pages) => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n  return\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n  return\n}\n","import type { QueryFilters, Updater, MutationFilters } from './utils'\nimport {\n  hashQueryKey,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n  hashQueryKeyByOptions,\n  functionalUpdate,\n} from './utils'\nimport type {\n  QueryClientConfig,\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  ResetQueryFilters,\n  SetDataOptions,\n  WithRequired,\n} from './types'\nimport type { QueryState } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type { CancelOptions, DefaultedQueryObserverOptions } from './types'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private logger: Logger\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private mountCount: number\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.logger = config.logger || defaultLogger\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n    this.mountCount = 0\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\n        `Passing a custom logger has been deprecated and will be removed in the next major version.`,\n      )\n    }\n  }\n\n  mount(): void {\n    this.mountCount++\n    if (this.mountCount !== 1) return\n\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.mountCount--\n    if (this.mountCount !== 0) return\n\n    this.unsubscribeFocus?.()\n    this.unsubscribeFocus = undefined\n\n    this.unsubscribeOnline?.()\n    this.unsubscribeOnline = undefined\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKey, filters?: QueryFilters): number\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetchStatus = 'fetching'\n    return this.queryCache.findAll(filters).length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.mutationCache.findAll({ ...filters, fetching: true }).length\n  }\n\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): TQueryFnData | undefined {\n    return this.queryCache.find<TQueryFnData>(queryKey, filters)?.state.data\n  }\n\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: WithRequired<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | WithRequired<\n          FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n          'queryKey'\n        >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const cachedData = this.getQueryData<TData>(parsedOptions.queryKey!)\n\n    return cachedData\n      ? Promise.resolve(cachedData)\n      : this.fetchQuery(parsedOptions)\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return this.getQueryCache()\n      .findAll(queryKeyOrFilters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TQueryFnData | undefined\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): TQueryFnData | undefined {\n    const query = this.queryCache.find<TQueryFnData>(queryKey)\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(queryKeyOrFilters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<TQueryFnData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): QueryState<TQueryFnData, TError> | undefined {\n    return this.queryCache.find<TQueryFnData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void\n  removeQueries(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKey | ResetQueryFilters,\n    arg2?: ResetQueryFilters | ResetOptions,\n    arg3?: ResetOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: CancelOptions,\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions,\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(cancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKey | RefetchQueryFilters,\n    arg2?: RefetchQueryFilters | RefetchOptions,\n    arg3?: RefetchOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) =>\n          query.fetch(undefined, {\n            ...options,\n            cancelRefetch: options?.cancelRefetch ?? true,\n            meta: { refetchPage: filters.refetchPage },\n          }),\n        ),\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    return this.mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getLogger(): Logger {\n    return this.logger\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<unknown, any, any, any>,\n  ): void {\n    const result = this.queryDefaults.find(\n      (x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    if (!queryKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.queryDefaults.find((x) =>\n      partialMatchKey(queryKey, x.queryKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter((x) =>\n        partialMatchKey(queryKey, x.queryKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several query defaults match with key '${JSON.stringify(\n            queryKey,\n          )}'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>,\n  ): void {\n    const result = this.mutationDefaults.find(\n      (x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    if (!mutationKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.mutationDefaults.find((x) =>\n      partialMatchKey(mutationKey, x.mutationKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter((x) =>\n        partialMatchKey(mutationKey, x.mutationKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several mutation defaults match with key '${JSON.stringify(\n            mutationKey,\n          )}'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  defaultQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey extends QueryKey,\n  >(\n    options?:\n      | QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n","import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  cacheTime!: number\n  private gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.cacheTime)\n    }\n  }\n\n  protected updateCacheTime(newCacheTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(\n      this.cacheTime || 0,\n      newCacheTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout)\n      this.gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport type { CancelOptions, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = unknown>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n","type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: TListener[]\n\n  constructor() {\n    this.listeners = []\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.push(listener as TListener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners = this.listeners.filter((x) => x !== listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.length > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => array2.indexOf(x) === -1)\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>,\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1) ? [{ ...arg2, queryKey: arg1 }, arg3] : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1)\n      ? [{ ...arg2, mutationKey: arg1 }, arg3]\n      : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n  return\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client\n      .getLogger()\n      .error(\n        `The contextSharing option has been deprecated and will be removed in the next major version`,\n      )\n  }\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","'use client'\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nimport { useSyncExternalStore as uSES } from 'use-sync-external-store/shim/index.js'\n\nexport const useSyncExternalStore = uSES\n","import type { Action, Mutation } from './mutation'\nimport { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverBaseResult,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from './types'\nimport { shallowEqualObjects } from './utils'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options\n    this.options = this.client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this,\n      })\n    }\n    this.currentMutation?.setOptions(this.options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables:\n        typeof variables !== 'undefined' ? variables : this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    const result: MutationObserverBaseResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    > = {\n      ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n\n    this.currentResult = result as MutationObserverResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    >\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!,\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n","'use client'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { MutationFunction, MutationKey } from '@tanstack/query-core'\nimport {\n  notifyManager,\n  parseMutationArgs,\n  MutationObserver,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n"],"names":["focusManager","_Subscribable","_inherits","FocusManager","_super","_createSuper","_this","_classCallCheck","call","setup","onFocus","isServer","window","addEventListener","listener","removeEventListener","_createClass","key","value","this","cleanup","setEventListener","_this$cleanup","hasListeners","undefined","_this$cleanup2","_this2","focused","setFocused","listeners","forEach","document","includes","visibilityState","Subscribable","defaultLogger","console","Mutation","_Removable","config","defaultOptions","mutationId","mutationCache","logger","observers","state","getDefaultState","setOptions","options","scheduleGc","_objectSpread","updateCacheTime","cacheTime","get","meta","dispatch","type","observer","indexOf","push","clearGcTimeout","notify","mutation","filter","x","length","status","remove","_this$retryer$continu","_this$retryer","retryer","continue","execute","_execute","_asyncToGenerator","_regeneratorRuntime","mark","_callee","executeMutation","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","context","data","_this$mutationCache$c7","_this$mutationCache$c8","_this$options$onError","_this$options4","_this$mutationCache$c9","_this$mutationCache$c10","_this$options$onSettl2","_this$options5","wrap","_context","prev","next","_this$options$retry","createRetryer","fn","mutationFn","variables","Promise","reject","onFail","failureCount","error","onPause","onContinue","retry","retryDelay","networkMode","promise","onMutate","sent","onSuccess","onSettled","abrupt","t0","onError","finish","stop","apply","arguments","action","_this3","failureReason","isPaused","canFetch","reducer","notifyManager","onMutationUpdate","Removable","queue","transactions","notifyFn","callback","batchNotifyFn","schedule","scheduleMicrotask","flush","originalQueue","batch","result","batchCalls","_len","args","Array","_key","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","onlineManager","OnlineManager","onOnline","online","setOnline","navigator","onLine","Query","abortSignalConsumed","cache","queryKey","queryHash","initialState","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","Date","now","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","fetchStatus","newData","replaceData","updatedAt","manual","setStateOptions","cancel","then","noop","catch","resolve","_get","_getPrototypeOf","prototype","silent","destroy","setState","some","enabled","getObserversCount","isActive","getCurrentResult","isStale","staleTime","timeUntilStale","_this$retryer2","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","query","revert","cancelRetry","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","continueRetry","queryFn","isArray","abortController","getAbortController","queryFnContext","pageParam","addSignalProperty","object","Object","defineProperty","enumerable","signal","_context$fetchOptions2","fetchFn","behavior","onFetch","revertState","_this$cache$config$on","_this$cache$config","_this$cache$config$on2","_this$cache$config2","isCancelledError","isFetchingOptimistic","abort","bind","_this$cache$config$on3","_this$cache$config3","_this$cache$config$on4","_this$cache$config4","setData","Error","_action$meta","_action$dataUpdatedAt","onQueryUpdate","QueryCache","queries","queriesMap","client","_options$queryHash","hashQueryKeyByOptions","getLogger","defaultQueryOptions","getQueryDefaults","add","queryInMap","arg1","arg2","_parseFilterArgs","parseFilterArgs","filters","_slicedToArray","exact","matchQuery","_parseFilterArgs3","keys","event","_this4","_this5","MutationCache","mutations","defaultMutationOptions","mutationKey","getMutationDefaults","matchMutation","_this$resuming","resuming","pausedMutations","reduce","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","buildNewPages","param","page","previous","concat","_toConsumableArray","fetchPage","_context$signal","_context$signal2","aborted","queryFnResult","getNextPageParam","getPreviousPageParam","shouldFetchFirstPage","_loop","i","QueryClient","queryCache","queryDefaults","mutationDefaults","mountCount","unsubscribeFocus","resumePausedMutations","unsubscribeOnline","_this$unsubscribeFocu","_this$unsubscribeOnli","findAll","fetching","_this$queryCache$find","arg3","parsedOptions","parseQueryArgs","cachedData","getQueryData","fetchQuery","queryKeyOrFilters","getQueryCache","map","_ref2","updater","prevData","functionalUpdate","defaultedOptions","build","_ref3","setQueryData","_this$queryCache$find2","_parseFilterArgs5","_parseFilterArgs6","refetchFilters","reset","refetchQueries","_parseFilterArgs7","_parseFilterArgs8","_parseFilterArgs8$","cancelOptions","promises","all","_parseFilterArgs9","_parseFilterArgs10","_ref","_filters$refetchType","invalidate","refetchType","_this6","_parseFilterArgs11","_parseFilterArgs12","isDisabled","_options$cancelRefetc","fetch","throwOnError","isStaleByTime","fetchInfiniteQuery","hashQueryKey","firstMatchingDefaults","partialMatchKey","_defaulted","refetchOnReconnect","useErrorBoundary","suspense","clear","isValidTimeout","gcTimeout","setTimeout","optionalRemove","newCacheTime","Math","max","Infinity","clearTimeout","defaultRetryDelay","min","pow","CancelledError","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","outerResolve","outerReject","shouldPause","pause","continueResolve","canContinue","run","promiseOrValue","_config$retry","_config$retryDelay","delay","shouldRetry","sleep","subscribe","onSubscribe","onUnsubscribe","input","isQueryKey","parseMutationArgs","_filters$type","predicate","stale","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","sort","a","b","partialDeepEqual","replaceEqualDeep","array","isPlainArray","aSize","bItems","bSize","copy","equalItems","shallowEqualObjects","o","hasObjectPrototype","ctor","constructor","prot","hasOwnProperty","toString","timeout","AbortController","isDataEqual","structuralSharing","defaultContext","React","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","QueryClientProvider","_ref2$contextSharing","mount","unmount","Context","useSyncExternalStore","useSyncExternalStore$1","MutationObserver","bindMethods","updateResult","mutate","_this$currentMutation","prevOptions","getMutationCache","currentMutation","_this$currentMutation2","removeObserver","notifyOptions","currentResult","mutateOptions","addObserver","isLoading","isSuccess","isError","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","useMutation","_React$useState","_useErrorBoundary","params","onStoreChange"],"sourceRoot":""}